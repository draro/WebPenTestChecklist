# WEB APP PENTESTING CHECKLIST

## Information gathering

1. Search engine recon
2. Webserver fingerprint
3. Source code investigations
4. Asset discovery
5. User emulation ( Keep MiTM proxy open for site map population )
6. Endpoint discovery
7. Enumerate any admin interfaces
8. Enumeration of errors and stack traces
9. Fingerprint the application
10. Map the application architecture
11. Map out integration points
12. Find:

    - Data flows
    - Paths
    - Race’s

## Exploits

1. Login system

- Token Verification
  - [Test the JWT token](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/10-Testing_JSON_Web_Tokens)
  - Signature Verification
  - The none signing algorithm sometimes is accepted
  - Weak HMAC Keys
  - HMAC vs Public Key Confusion

2. Login bypass

   - Directory brute force
   - SQLi
   - Session ID prediction

3. Username enumeration
4. Register a user with XSS attack vector in every input field, use for further testing
5. Weak password systems
6. Test password reset systems
   - Add second email parameter with email of attacker
   - Any tokens sent over HTTP
   - Weak predictable tokens
   - Is the user forced to reauthenticate
7. SessionID in URL
8. Logout should invalidate session tokens
9. [Testing for session puzzling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/08-Testing_for_Session_Puzzling)
10. [Session hijacking](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/09-Testing_for_Session_Hijacking)
    - Request from attackers website to victims bank for example to login. The bank will possibly return session vars if bad config. This leads to attackers owning session vars now.

## Input validation

1. XSS
2. Reflected XSS
3. Stored XSS
4. Blind XSS
5. DOM XSS
6. SQLi
7. XXE
8. Command injection
9. SSTI/CSTI
   - Insert ${7\*7} into every field you see, if it resolves, investigate further
10. SSRF
    - Add burp collaborator URL in everywhere that URL resolves
11. [HTTP parameter polution](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution)
12. LDAP injection
13. SSI (server side includes injection)
14. XPath injection
15. Clickjacking
16. GraphQL testing

## General exploits

1. RFI/LFI
2. Insecure session management
3. Subdomain takeover
4. Check if user role is user controllable (Can you make yourself admin)
5. Test the cookies attributes
   - Sensitive cookies should have secure and httponly flag
   - Domain and path need to be set right
   - Expires in timely manner
   - SameSite Attribute
6. CSRF testing
   - Only on sensitive functions, not on login/logout
7. File upload testing
   - Uploading of malicious content
   - File upload restrictions
     - Changing mimetype
     - Using nullbytes
8. Test integration points for overextended priviledges
9. Test if the browser caches sensitive information
   - Use the back button after logout timer
   - Click around after login timer
   - Check cache headers on sensitive pages
10. There should not be any weak encryption used anywhere
    - Search for the following keywords to identify use of weak algorithms: MD4, MD5, RC4, RC2, DES, Blowfish, SHA-1, ECB

## Business logic flaws

1. Data validation
   - example may be if I use my credit card at multiple locations very quickly it may be possible to exceed my limit if the systems are basing decisions on last night’s data.
   - Identify data injection points.
   - Validate that all checks are occurring on the back end and can’t be bypassed.
   - Attempt to break the format of the expected data and analyze how the application is handling it.
2. Test for hidden parameters that you can change with impact.
   - For example changing account type from consumer to business
3. Check for things that are only hidden in the front-end
4. Check for disabled fields that are only front-end disabled
5. Integrity checks
   - Review the project documentation for components of the system that move, store, or handle data.
   - Determine what type of data is logically acceptable by the component and what types the system should guard against.
   - Determine who should be allowed to modify or read that data in each component.
   - Attempt to insert, update, or delete data values used by each component that should not be allowed per the business logic workflow.
6. Test functions that can only be used a limited amount of times
   - For example a coupon code that you should only be applying one time but that’s just a front-end check
7. If something gets added to account and should be withdrawn again, check if it is.
   - For example if you order an item but cancel the order, your loyatee points should go down as well.
